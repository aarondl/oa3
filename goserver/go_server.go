package goserver

import (
	"bytes"
	"fmt"
	"go/format"
	"io/fs"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"github.com/aarondl/oa3/generator"
	"github.com/aarondl/oa3/openapi3spec"
	"github.com/aarondl/oa3/templates"
)

const (
	// DefaultPackage name for go
	DefaultPackage = "oa3gen"
	// Disclaimer printed to the top of Go files
	Disclaimer = `// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.`
)

// Constants for keys recognized in the parameters for the Go server
const (
	ParamKeyPackage  = "package"
	ParamKeyTimeType = "timetype"
)

// templates for generation
var TemplateList = []string{
	"api_interface.tpl",
	"api_methods.tpl",
	"responses.tpl",
	"schema.tpl",
	"schema_top.tpl",

	"validate_schema.tpl",
	"validate_field.tpl",
}

// TemplateFunctions to use for generation
var TemplateFunctions = map[string]interface{}{
	"camelSnake":              CamelSnake,
	"primitive":               primitive,
	"primitiveRaw":            primitiveRaw,
	"primitiveBits":           primitiveBits,
	"isInlinePrimitive":       isInlinePrimitive,
	"taggedPaths":             tagPaths,
	"responseKind":            responseKind,
	"omitnullWrap":            omitnullWrap,
	"omitnullConstructorWrap": omitnullConstructorWrap,

	// overrides of the defaults
	"mustValidate": mustValidate,
}

// generator generates templates for Go
type gen struct {
	tpl *template.Template
}

// New go generator
func New() generator.Interface {
	return &gen{}
}

// Load templates
func (g *gen) Load(dir fs.FS) error {
	var err error
	g.tpl, err = templates.Load(TemplateFunctions, dir, TemplateList...)
	return err
}

// Do generation for Go.
func (g *gen) Do(spec *openapi3spec.OpenAPI3, params map[string]string) ([]generator.File, error) {
	if params == nil {
		params = make(map[string]string)
	}
	if pkg, ok := params[ParamKeyPackage]; !ok || len(pkg) == 0 {
		params[ParamKeyPackage] = DefaultPackage
	}

	var files []generator.File
	f, err := GenerateTopLevelSchemas(spec, params, g.tpl)
	if err != nil {
		return nil, fmt.Errorf("failed to generate schemas: %w", err)
	}

	files = append(files, f...)

	f, err = generateAPIInterface(spec, params, g.tpl)
	if err != nil {
		return nil, fmt.Errorf("failed to api interface: %w", err)
	}

	files = append(files, f...)

	for i, f := range files {
		formatted, err := format.Source(f.Contents)
		if err != nil {
			return nil, fmt.Errorf("failed to format file(%s): %w\n%s", f.Name, err, f.Contents)
		}

		files[i].Contents = formatted
	}

	return files, nil
}

func generateAPIInterface(spec *openapi3spec.OpenAPI3, params map[string]string, tpl *template.Template) ([]generator.File, error) {
	if spec.Paths == nil {
		return nil, nil
	}

	files := make([]generator.File, 0)

	apiName := strings.Title(strings.ReplaceAll(spec.Info.Title, " ", ""))

	data := templates.NewTemplateDataWithObject(spec, params, apiName, nil, false)

	filename := generator.FilenameFromTitle(spec.Info.Title) + ".go"

	buf := new(bytes.Buffer)
	if err := tpl.ExecuteTemplate(buf, "api_interface", data); err != nil {
		return nil, fmt.Errorf("failed rendering template %q: %w", "schema", err)
	}

	fileBytes := new(bytes.Buffer)
	pkg := params["package"]

	fileBytes.WriteString(Disclaimer)
	fmt.Fprintf(fileBytes, "\npackage %s\n", pkg)
	if imps := Imports(data.Imports); len(imps) != 0 {
		fileBytes.WriteByte('\n')
		fileBytes.WriteString(Imports(data.Imports))
		fileBytes.WriteByte('\n')
	}
	fileBytes.WriteByte('\n')
	fileBytes.Write(buf.Bytes())

	content := make([]byte, len(fileBytes.Bytes()))
	copy(content, fileBytes.Bytes())
	files = append(files, generator.File{Name: filename, Contents: content})

	data = templates.NewTemplateDataWithObject(spec, params, apiName, nil, false)
	filename = generator.FilenameFromTitle(spec.Info.Title) + "_methods.go"

	buf.Reset()
	fileBytes.Reset()
	if err := tpl.ExecuteTemplate(buf, "api_methods", data); err != nil {
		return nil, fmt.Errorf("failed rendering template %q: %w", "schema", err)
	}

	fileBytes.WriteString(Disclaimer)
	fmt.Fprintf(fileBytes, "\npackage %s\n", pkg)
	if imps := Imports(data.Imports); len(imps) != 0 {
		fileBytes.WriteByte('\n')
		fileBytes.WriteString(Imports(data.Imports))
		fileBytes.WriteByte('\n')
	}
	fileBytes.WriteByte('\n')
	fileBytes.Write(buf.Bytes())

	files = append(files, generator.File{Name: filename, Contents: fileBytes.Bytes()})

	return files, nil
}

// GenerateSchemas creates files for the topLevel-level referenceable types
//
// Some supported Inline are also generated.
// Prefixed with their recursive names and Inline.
// components.responses[name].headers[headername].schema
// components.responses[name].content[mime-type].schema
// components.responses[name].content[mime-type].encoding[propname].headers[headername].schema
// components.parameters[name].schema
// components.requestBodies[name].content[mime-type].schema
// components.requestBodies[name].content[mime-type].encoding[propname].headers[headername].schema
// components.headers[name].schema
// paths.parameters[0].schema
// paths.(get|put...).parameters[0].schema
// paths.(get|put...).requestBody.content[mime-type].schema
// paths.(get|put...).responses[name].headers[headername].schema
// paths.(get|put...).responses[name].content[mime-type].schema
// paths.(get|put...).responses[name].content[mime-type].encoding[propname].headers[headername].schema
func GenerateTopLevelSchemas(spec *openapi3spec.OpenAPI3, params map[string]string, tpl *template.Template) ([]generator.File, error) {
	if spec.Components == nil {
		return nil, nil
	}

	keys := make([]string, 0, len(spec.Components.Schemas))
	for k := range spec.Components.Schemas {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	topLevelStructs := make([]generator.File, 0, len(keys))

	for _, k := range keys {
		v := spec.Components.Schemas[k]
		filename := "schema_" + CamelSnake(k) + ".go"

		generated, err := makePseudoFile(spec, params, tpl, filename, k, v, false)
		if err != nil {
			return nil, err
		}
		topLevelStructs = append(topLevelStructs, generated)
	}

	type opMap struct {
		Verb string
		Op   *openapi3spec.Operation
	}

	for _, p := range spec.Paths {
		opMaps := []opMap{
			{"GET", p.Get}, {"POST", p.Post}, {"PUT", p.Put},
			{"PATCH", p.Patch}, {"TRACE", p.Trace}, {"HEAD", p.Head},
			{"DELETE", p.Delete},
		}
		for _, o := range opMaps {
			if o.Op == nil {
				continue
			}

			// If we have no request body ignore this op
			if o.Op.RequestBody != nil {
				if len(o.Op.RequestBody.Ref) != 0 {
					continue
				}

				schema := o.Op.RequestBody.Content["application/json"].Schema
				// Refs are taken care of already
				if len(schema.Ref) != 0 {
					continue
				}

				filename := "schema_" + CamelSnake(o.Op.OperationID) + "_reqbody.go"
				generated, err := makePseudoFile(spec, params, tpl, filename, strings.Title(o.Op.OperationID)+"Inline", &schema, o.Op.RequestBody.Required)
				if err != nil {
					return nil, err
				}

				topLevelStructs = append(topLevelStructs, generated)
			}
		}

		for _, o := range opMaps {
			if o.Op == nil {
				continue
			}

			for code, resp := range o.Op.Responses {
				if len(resp.Ref) != 0 {
					continue
				}
				if len(resp.Content) == 0 {
					continue
				}

				schema := resp.Content["application/json"].Schema
				// Refs are taken care of already
				if len(schema.Ref) != 0 {
					continue
				}

				filename := "schema_" + CamelSnake(o.Op.OperationID) + "_" + code + "_respbody.go"
				generated, err := makePseudoFile(spec, params, tpl, filename, strings.Title(o.Op.OperationID)+strings.Title(code)+"Inline", &schema, true)
				if err != nil {
					return nil, err
				}

				topLevelStructs = append(topLevelStructs, generated)
			}
		}
	}

	for name, req := range spec.Components.RequestBodies {
		schema := req.Content["application/json"].Schema
		if len(schema.Ref) != 0 {
			continue
		}

		filename := "schema_" + CamelSnake(name) + "_reqbody.go"
		generated, err := makePseudoFile(spec, params, tpl, filename, name+"Inline", &schema, req.Required)
		if err != nil {
			return nil, err
		}

		topLevelStructs = append(topLevelStructs, generated)
	}

	for name, resp := range spec.Components.Responses {
		if len(resp.Content) == 0 {
			continue
		}
		schema := resp.Content["application/json"].Schema
		if len(schema.Ref) != 0 {
			continue
		}

		filename := "schema_" + CamelSnake(name) + "_respbody.go"
		generated, err := makePseudoFile(spec, params, tpl, filename, name+"Inline", &schema, true)
		if err != nil {
			return nil, err
		}
		topLevelStructs = append(topLevelStructs, generated)
	}

	return topLevelStructs, nil
}

var (
	fileBuf   = new(bytes.Buffer)
	headerBuf = new(bytes.Buffer)
)

func makePseudoFile(spec *openapi3spec.OpenAPI3, params map[string]string, tpl *template.Template, filename string, name string, schema *openapi3spec.SchemaRef, required bool) (generator.File, error) {
	fileBuf.Reset()
	headerBuf.Reset()

	data := templates.NewTemplateDataWithObject(spec, params, name, schema, required)

	if err := tpl.ExecuteTemplate(fileBuf, "schema_top", data); err != nil {
		return generator.File{}, fmt.Errorf("failed rendering template %q: %w", "schema", err)
	}

	pkg := DefaultPackage
	if pkgParam := params["package"]; len(pkgParam) > 0 {
		pkg = pkgParam
	}

	headerBuf.WriteString(Disclaimer)
	fmt.Fprintf(headerBuf, "\npackage %s\n", pkg)
	if imps := Imports(data.Imports); len(imps) != 0 {
		headerBuf.WriteByte('\n')
		headerBuf.WriteString(Imports(data.Imports))
		headerBuf.WriteByte('\n')
	}
	headerBuf.WriteByte('\n')

	headerLen, fileLen := headerBuf.Len(), fileBuf.Len()
	contents := make([]byte, headerLen+fileLen)
	copy(contents, headerBuf.Bytes())
	copy(contents[headerLen:], fileBuf.Bytes())

	return generator.File{Name: filename, Contents: contents}, nil
}

func isInlinePrimitive(schema *openapi3spec.Schema) bool {
	if schema.Type == "object" {
		return schema.AdditionalProperties != nil
	}

	return true
}

func primitive(tdata templates.TemplateData, schema *openapi3spec.Schema, required bool) (string, error) {
	return primitiveWrapped(tdata, schema, schema.Nullable, required)
}

func primitiveRaw(tdata templates.TemplateData, schema *openapi3spec.Schema) (string, error) {
	switch schema.Type {
	case "integer":
		if schema.Format != nil {
			switch *schema.Format {
			case "int32":
				return "int32", nil
			case "int64":
				return "int64", nil
			}
		}

		return "int", nil
	case "number":
		if schema.Format != nil {
			switch *schema.Format {
			case "float":
				return "float32", nil
			case "double":
				return "float64", nil
			}
		}

		return "float64", nil
	case "string":
		if schema.Format != nil {
			switch *schema.Format {
			case "date":
				if tdata.Params[ParamKeyTimeType] == "chrono" {
					tdata.Import("github.com/aarondl/chrono")
					return "chrono.Date", nil
				} else {
					tdata.Import("time")
					return "time.Time", nil
				}
			case "time":
				if tdata.Params[ParamKeyTimeType] == "chrono" {
					tdata.Import("github.com/aarondl/chrono")
					return "chrono.Time", nil
				} else {
					tdata.Import("time")
					return "time.Time", nil
				}
			case "date-time":
				if tdata.Params[ParamKeyTimeType] == "chrono" {
					tdata.Import("github.com/aarondl/chrono")
					return "chrono.DateTime", nil
				} else {
					tdata.Import("time")
					return "time.Time", nil
				}
			case "duration":
				tdata.Import("time")
				return "time.Duration", nil
			}
		}
		return "string", nil
	case "boolean":
		return "bool", nil
	}

	return "", fmt.Errorf("schema expected primitive type (integer, number, string, boolean) but got: %s", schema.Type)
}

func primitiveBits(tdata templates.TemplateData, schema *openapi3spec.Schema) (string, error) {
	s, err := primitiveRaw(tdata, schema)
	if err != nil {
		return "", nil
	}

	ret := strings.Map(func(r rune) rune {
		if unicode.IsLetter(r) {
			return -1
		}
		return r
	}, s)

	if len(ret) == 0 {
		return "64", nil
	} else {
		return ret, nil
	}
}

func primitiveWrapped(tdata templates.TemplateData, schema *openapi3spec.Schema, nullable bool, required bool) (string, error) {
	prim, err := primitiveRaw(tdata, schema)
	if err != nil {
		return "", err
	}

	return omitnullWrap(tdata, schema, prim, nullable, required), nil
}

func omitnullWrap(tdata templates.TemplateData, schema *openapi3spec.Schema, typ string, nullable bool, required bool) string {
	var kind string
	switch {
	case !nullable && required:
		return typ
	case nullable && required:
		kind = "null"
	case nullable && !required:
		kind = "omitnull"
	case !nullable && !required:
		kind = "omit"
	}

	tdata.Import("github.com/aarondl/opt/" + kind)
	return kind + `.Val[` + typ + `]`
}

func omitnullConstructorWrap(tdata templates.TemplateData, schema *openapi3spec.Schema, value string, nullable bool, required bool) string {
	var kind string
	switch {
	case !nullable && required:
		return value
	case nullable && required:
		kind = "null"
	case nullable && !required:
		kind = "omitnull"
	case !nullable && !required:
		kind = "omit"
	}

	tdata.Import("github.com/aarondl/opt/" + kind)
	return kind + `.From(` + value + `)`
}

// mustValidate checks to see if the schema requires any kind of validation
// overrides the generic definition
//
// The general reason to have overridded this is because
// date/datetime/time/duration types are handled by using a type that validates
// it on parse/convert so there's no reason to generate validation after
// the conversion has already been done.
func mustValidate(s *openapi3spec.Schema) bool {
	return s.MultipleOf != nil ||
		s.Maximum != nil ||
		s.Minimum != nil ||
		s.MaxLength != nil ||
		s.MinLength != nil ||
		s.Pattern != nil ||
		s.MaxItems != nil ||
		s.MinItems != nil ||
		s.UniqueItems != nil ||
		s.MaxProperties != nil ||
		s.MinProperties != nil ||
		(s.Format != nil && *s.Format != "date" && *s.Format != "date-time" && *s.Format != "time" && *s.Format != "duration")
}

func Imports(imps map[string]struct{}) string {
	if len(imps) == 0 {
		return ""
	}

	var std, third []string
	for imp := range imps {
		splits := strings.Split(imp, "/")
		if len(splits) > 0 && strings.ContainsRune(splits[0], '.') {
			third = append(third, imp)
			continue
		}

		std = append(std, imp)
	}

	sort.Strings(std)
	sort.Strings(third)

	buf := new(bytes.Buffer)
	buf.WriteString("import (")
	for _, imp := range std {
		fmt.Fprintf(buf, "\n\t\"%s\"", imp)
	}
	if len(std) != 0 && len(third) != 0 {
		buf.WriteByte('\n')
	}
	for _, imp := range third {
		fmt.Fprintf(buf, "\n\t\"%s\"", imp)
	}
	buf.WriteString("\n)")

	return buf.String()
}

// schema_UserIDProfile -> schema_user_id_profile
// ID -> id
func CamelSnake(filename string) string {
	build := new(strings.Builder)

	var upper bool

	in := []rune(filename)
	for i, r := range []rune(in) {
		if !unicode.IsLetter(r) {
			upper = false
			build.WriteRune(r)
			continue
		}

		if !unicode.IsUpper(r) {
			upper = false
			build.WriteRune(r)
			continue
		}

		addUnderscore := false
		if upper {
			if i+1 < len(in) && unicode.IsLower(in[i+1]) {
				addUnderscore = true
			}
		} else {
			if i-1 > 0 && unicode.IsLetter(in[i-1]) {
				addUnderscore = true
			}
		}

		if addUnderscore {
			build.WriteByte('_')
		}

		upper = true
		build.WriteRune(unicode.ToLower(r))
	}

	return build.String()
}

// responseKind returns the type of abstraction we need for a specific response
// code in an operation.
//
// The return can be one of three values: "wrapped" "empty" or ""
//
// Wrapped indicates it must be wrapped in a struct because it either has
// headers or it is a duplicate response type (say two strings) and we need
// to differentiate code.
//
// Empty means there is no response body, and an empty response code type
// must be used in its place.
//
// An empty string means that no special handling is required and the type
// response type can be used directly.
func responseKind(op *openapi3spec.Operation, code string) string {
	r := op.Responses[code]
	if len(r.Headers) != 0 {
		return "wrapped"
	}

	// Return here since there's no point continuing if we can't find bodies to
	// collide with
	if len(r.Content) == 0 {
		return "empty"
	}

	body := r.Content["application/json"].Schema

	for respCode, resp := range op.Responses {
		if respCode == code {
			continue
		}

		// Don't compare bodies if the other one doesn't have one
		if len(resp.Content) == 0 {
			continue
		}

		otherBody := resp.Content["application/json"].Schema
		if len(body.Ref) != 0 && len(otherBody.Ref) != 0 && body.Ref == otherBody.Ref {
			return "wrapped"
		} else if len(body.Ref) == 0 && len(otherBody.Ref) == 0 && body.Type == otherBody.Type {
			if isInlinePrimitive(body.Schema) {
				return "wrapped"
			}
		}
	}

	return ""
}
