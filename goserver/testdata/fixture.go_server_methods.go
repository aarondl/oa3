// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package oa3gen

import (
	"errors"
	"net/http"

	"github.com/aarondl/oa3/support"
	"github.com/volatiletech/null/v8"
)

// AlreadyHandled is an interface which an error return type can optionally
// implement to stop the generated method from responding in anyway, it will
// swallow the error and not touch the ResponseWriter if this method returns
// true.
type AlreadyHandled interface {
	AlreadyHandled() bool
}

// ErrHandled is a sentinel error that implements
// the AlreadyHandled interface which prevents the
// generated handler from firing.
type ErrHandled struct{}

// Error implements error
func (ErrHandled) Error() string { return "already handled" }

// AlreadyHandled implements AlreadyHandled
func (ErrHandled) AlreadyHandled() bool { return true }

// authenticate post /auth
func (o GoServer) authenticateOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	ret, err := o.impl.Authenticate(w, r)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinlineprimitivebody get /test/inline
func (o GoServer) testinlineprimitivebodyOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlinePrimitiveBodyInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInlinePrimitiveBody(w, r, string(reqBody))
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinline post /test/inline
func (o GoServer) testinlineOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlineInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInline(w, r, reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case TestInline200Inline:
		w.WriteHeader(200)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case TestInline201Inline:
		w.WriteHeader(201)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// getuser get /users/{id}
func (o GoServer) getuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	const n0 = `valid_str`
	s0 := r.URL.Query().Get(n0)
	var p0 null.String
	if len(s0) != 0 {
		p0, err = support.StringToNullstring(s0)
		if err != nil {
			errs = support.AddErrs(errs, n0, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(string(p0.String), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(string(p0.String), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(string(p0.String), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n0, ers...)
		}
	}

	const n1 = `req_valid_str`
	s1 := r.URL.Query().Get(n1)
	var p1 null.String
	if len(s1) == 0 {
		errs = support.AddErrs(errs, n1, errors.New(`must not be empty`))
	} else {
		p1, err = support.StringToNullstring(s1)
		if err != nil {
			errs = support.AddErrs(errs, n1, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(string(p1.String), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(string(p1.String), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(string(p1.String), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n1, ers...)
		}
	}

	const n2 = `valid_int`
	s2 := r.URL.Query().Get(n2)
	var p2 int
	if len(s2) != 0 {
		p2, err = support.StringToInt(s2)
		if err != nil {
			errs = support.AddErrs(errs, n2, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxInt(int64(p2), 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinInt(int64(p2), 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(int64(p2), 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n2, ers...)
		}
	}

	const n3 = `req_valid_int`
	s3 := r.URL.Query().Get(n3)
	var p3 int
	if len(s3) == 0 {
		errs = support.AddErrs(errs, n3, errors.New(`must not be empty`))
	} else {
		p3, err = support.StringToInt(s3)
		if err != nil {
			errs = support.AddErrs(errs, n3, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxInt(int64(p3), 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinInt(int64(p3), 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(int64(p3), 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n3, ers...)
		}
	}

	const n4 = `valid_num`
	s4 := r.URL.Query().Get(n4)
	var p4 float64
	if len(s4) != 0 {
		p4, err = support.StringToFloat64(s4)
		if err != nil {
			errs = support.AddErrs(errs, n4, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxFloat64(float64(p4), 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinFloat64(float64(p4), 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat64(float64(p4), 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n4, ers...)
		}
	}

	const n5 = `req_valid_num`
	s5 := r.URL.Query().Get(n5)
	var p5 float64
	if len(s5) != 0 {
		p5, err = support.StringToFloat64(s5)
		if err != nil {
			errs = support.AddErrs(errs, n5, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxFloat64(float64(p5), 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinFloat64(float64(p5), 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat64(float64(p5), 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n5, ers...)
		}
	}

	const n6 = `valid_bool`
	s6 := r.URL.Query().Get(n6)
	var p6 bool
	if len(s6) != 0 {
		p6, err = support.StringToBool(s6)
		if err != nil {
			errs = support.AddErrs(errs, n6, errors.New(`was not in a valid format`))
		}
	}

	const n7 = `req_valid_bool`
	s7 := r.URL.Query().Get(n7)
	var p7 bool
	if len(s7) == 0 {
		errs = support.AddErrs(errs, n7, errors.New(`must not be empty`))
	} else {
		p7, err = support.StringToBool(s7)
		if err != nil {
			errs = support.AddErrs(errs, n7, errors.New(`was not in a valid format`))
		}
	}

	ret, err := o.impl.GetUser(w, r, p0, p1, p2, p3, p4, p5, p6, p7)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusNotModified:
		w.WriteHeader(304)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// setuser post /users/{id}
func (o GoServer) setuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody Primitives

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.SetUser(w, r, &reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case SetUser200WrappedResponse:
		headers := w.Header()
		if respBody.HeaderXResponseHeader.Valid {
			headers.Set("X-Response-Header", respBody.HeaderXResponseHeader.String)
		}
		w.WriteHeader(200)
		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case SetUserdefaultWrappedResponse:

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}
