// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package oa3gen

import (
	"errors"
	"net/http"
	"time"

	"github.com/aarondl/chrono"
	"github.com/aarondl/oa3/support"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/go-chi/chi/v5"
)

// AlreadyHandled is an interface which an error return type can optionally
// implement to stop the generated method from responding in anyway, it will
// swallow the error and not touch the ResponseWriter if this method returns
// true.
type AlreadyHandled interface {
	AlreadyHandled() bool
}

// ErrHandled is a sentinel error that implements
// the AlreadyHandled interface which prevents the
// generated handler from firing.
type ErrHandled struct{}

// Error implements error
func (ErrHandled) Error() string { return "already handled" }

// AlreadyHandled implements AlreadyHandled
func (ErrHandled) AlreadyHandled() bool { return true }

// authenticate post /auth
func (o GoServer) authenticateOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.Authenticate(w, r)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testarrayrequest get /test/array/request
func (o GoServer) testarrayrequestOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestArrayRequestInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := Validate(reqBody); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestArrayRequest(w, r, reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinlineprimitivebody get /test/inline
func (o GoServer) testinlineprimitivebodyOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlinePrimitiveBodyInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := Validate(reqBody); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInlinePrimitiveBody(w, r, string(reqBody))
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinline post /test/inline
func (o GoServer) testinlineOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlineInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := Validate(reqBody); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInline(w, r, reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case TestInline200Inline:
		w.WriteHeader(200)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case TestInline201Inline:
		w.WriteHeader(201)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// getuser get /users/{id}
func (o GoServer) getuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	const n0 = `id`
	s0, s0Exists := chi.URLParam(r, n0), true
	var p0 string
	if !s0Exists || len(s0) == 0 {
		errs = support.AddErrs(errs, n0, errors.New(`must be provided and not be empty`))
	} else {
		p0 = s0
	}

	const n1 = `valid_str`
	s1, s1Exists := r.Header.Get(n1), len(r.Header.Values(n1)) != 0
	var p1 omitnull.Val[string]
	if s1Exists {
		p1.Set(s1)
		err = nil
		if err != nil {
			errs = support.AddErrs(errs, n1, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(omitnull.Val[string](p1).GetOrZero(), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(omitnull.Val[string](p1).GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(omitnull.Val[string](p1).GetOrZero(), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n1, ers...)
		}
	}

	const n2 = `req_valid_str`
	s2, s2Exists := r.URL.Query().Get(n2), r.URL.Query().Has(n2)
	var p2 null.Val[string]
	if !s2Exists || len(s2) == 0 {
		errs = support.AddErrs(errs, n2, errors.New(`must be provided and not be empty`))
	} else {
		p2.Set(s2)
		err = nil
		if err != nil {
			errs = support.AddErrs(errs, n2, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(null.Val[string](p2).GetOrZero(), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(null.Val[string](p2).GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(null.Val[string](p2).GetOrZero(), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n2, ers...)
		}
	}

	const n3 = `valid_int`
	s3, s3Exists := r.URL.Query().Get(n3), r.URL.Query().Has(n3)
	var p3 omit.Val[int]
	if s3Exists {
		p3c, err := support.StringToInt[int](s3, 64)
		p3.Set(p3c)
		if err != nil {
			errs = support.AddErrs(errs, n3, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p3.GetOrZero(), 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p3.GetOrZero(), 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(p3.GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n3, ers...)
		}
	}

	const n4 = `req_valid_int`
	s4, s4Exists := r.URL.Query().Get(n4), r.URL.Query().Has(n4)
	var p4 int
	if !s4Exists || len(s4) == 0 {
		errs = support.AddErrs(errs, n4, errors.New(`must be provided and not be empty`))
	} else {
		p4, err = support.StringToInt[int](s4, 64)
		if err != nil {
			errs = support.AddErrs(errs, n4, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p4, 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p4, 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(p4, 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n4, ers...)
		}
	}

	const n5 = `valid_num`
	s5, s5Exists := r.URL.Query().Get(n5), r.URL.Query().Has(n5)
	var p5 omit.Val[float64]
	if s5Exists {
		p5c, err := support.StringToFloat[float64](s5, 64)
		p5.Set(p5c)
		if err != nil {
			errs = support.AddErrs(errs, n5, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p5.GetOrZero(), 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p5.GetOrZero(), 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat(p5.GetOrZero(), 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n5, ers...)
		}
	}

	const n6 = `req_valid_num`
	s6, s6Exists := r.URL.Query().Get(n6), r.URL.Query().Has(n6)
	var p6 float64
	if !s6Exists || len(s6) == 0 {
		errs = support.AddErrs(errs, n6, errors.New(`must be provided and not be empty`))
	} else {
		p6, err = support.StringToFloat[float64](s6, 64)
		if err != nil {
			errs = support.AddErrs(errs, n6, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p6, 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p6, 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat(p6, 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n6, ers...)
		}
	}

	const n7 = `valid_bool`
	s7, s7Exists := r.URL.Query().Get(n7), r.URL.Query().Has(n7)
	var p7 omit.Val[bool]
	if s7Exists {
		p7c, err := support.StringToBool(s7)
		p7.Set(p7c)
		if err != nil {
			errs = support.AddErrs(errs, n7, errors.New(`was not in a valid format`))
		}
	}

	const n8 = `req_valid_bool`
	s8, s8Exists := r.URL.Query().Get(n8), r.URL.Query().Has(n8)
	var p8 bool
	if !s8Exists || len(s8) == 0 {
		errs = support.AddErrs(errs, n8, errors.New(`must be provided and not be empty`))
	} else {
		p8, err = support.StringToBool(s8)
		if err != nil {
			errs = support.AddErrs(errs, n8, errors.New(`was not in a valid format`))
		}
	}

	const n9 = `req_str_format`
	s9, s9Exists := r.URL.Query().Get(n9), r.URL.Query().Has(n9)
	var p9 string
	if !s9Exists || len(s9) == 0 {
		errs = support.AddErrs(errs, n9, errors.New(`must be provided and not be empty`))
	} else {
		p9 = s9
		ers = nil
		if err := support.ValidateFormatUUIDv4(p9); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n9, ers...)
		}
	}

	const n10 = `date_time`
	s10, s10Exists := r.URL.Query().Get(n10), r.URL.Query().Has(n10)
	var p10 chrono.DateTime
	if !s10Exists || len(s10) == 0 {
		errs = support.AddErrs(errs, n10, errors.New(`must be provided and not be empty`))
	} else {
		p10, err = support.StringToChronoDateTime(s10)
		if err != nil {
			errs = support.AddErrs(errs, n10, errors.New(`was not in a valid format`))
		}
	}

	const n11 = `date`
	s11, s11Exists := r.URL.Query().Get(n11), r.URL.Query().Has(n11)
	var p11 chrono.Date
	if !s11Exists || len(s11) == 0 {
		errs = support.AddErrs(errs, n11, errors.New(`must be provided and not be empty`))
	} else {
		p11, err = support.StringToChronoDate(s11)
		if err != nil {
			errs = support.AddErrs(errs, n11, errors.New(`was not in a valid format`))
		}
	}

	const n12 = `time_val`
	s12, s12Exists := r.URL.Query().Get(n12), r.URL.Query().Has(n12)
	var p12 chrono.Time
	if !s12Exists || len(s12) == 0 {
		errs = support.AddErrs(errs, n12, errors.New(`must be provided and not be empty`))
	} else {
		p12, err = support.StringToChronoTime(s12)
		if err != nil {
			errs = support.AddErrs(errs, n12, errors.New(`was not in a valid format`))
		}
	}

	const n13 = `duration_val`
	s13, s13Exists := r.URL.Query().Get(n13), r.URL.Query().Has(n13)
	var p13 time.Duration
	if !s13Exists || len(s13) == 0 {
		errs = support.AddErrs(errs, n13, errors.New(`must be provided and not be empty`))
	} else {
		p13, err = support.StringToDuration(s13)
		if err != nil {
			errs = support.AddErrs(errs, n13, errors.New(`was not in a valid format`))
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.GetUser(w, r, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusNotModified:
		w.WriteHeader(304)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// setuser post /users/{id}
func (o GoServer) setuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody Primitives

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := Validate(reqBody); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.SetUser(w, r, &reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case SetUser200WrappedResponse:
		headers := w.Header()
		if val, ok := respBody.HeaderXResponseHeader.Get(); ok {
			headers.Set("X-Response-Header", val)
		}
		w.WriteHeader(200)
		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case SetUserdefaultWrappedResponse:

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}
