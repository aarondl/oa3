// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package oa3gen

import (
	"strings"

	"github.com/aarondl/oa3/support"
	"github.com/volatiletech/null/v8"
)

// Checks to see that all Go primitives work
type Primitives struct {
	Bool        bool         `json:"bool"`
	BoolNull    null.Bool    `json:"bool_null"`
	Float       float64      `json:"float"`
	Float32     float32      `json:"float32"`
	Float32Null null.Float32 `json:"float32_null"`
	Float64     float64      `json:"float64"`
	Float64Null null.Float64 `json:"float64_null"`
	FloatNull   null.Float64 `json:"float_null"`
	// Normal int
	Int       int               `json:"int"`
	Int32     int32             `json:"int32"`
	Int32Null null.Int32        `json:"int32_null"`
	Int64     int64             `json:"int64"`
	Int64Null null.Int64        `json:"int64_null"`
	IntNull   null.Int          `json:"int_null"`
	Str       PrimitivesStr     `json:"str"`
	StrNull   PrimitivesStrNull `json:"str_null"`
}
type PrimitivesStr string

const (
	PrimitivesStrHello PrimitivesStr = "hello"
)

type PrimitivesStrNull null.String

var (
	PrimitivesStrNullHello PrimitivesStrNull = PrimitivesStrNull(null.StringFrom("hello"))
)

// VVValidateSchemaPrimitives validates the object and returns
// errors that can be returned to the user.
func (o Primitives) VVValidateSchema() support.Errors {
	var ctx []string
	var ers []error
	var errs support.Errors
	_, _, _ = ctx, ers, errs

	ers = nil
	if err := support.ValidateMultipleOfFloat64(float64(o.Float), 5.5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxFloat64(float64(o.Float32), 5.5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float32")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxFloat64(float64(o.Float32Null.Float32), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float32_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMinFloat64(float64(o.Float64), 5.5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float64")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMinFloat64(float64(o.Float64Null.Float64), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float64_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMultipleOfFloat64(float64(o.FloatNull.Float64), 5.5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMultipleOfInt(int64(o.Int), 5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxInt(int64(o.Int32), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int32")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxInt(int64(o.Int32Null.Int32), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int32_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMinInt(int64(o.Int64), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int64")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMinInt(int64(o.Int64Null.Int64), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int64_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMultipleOfInt(int64(o.IntNull.Int), 5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxLength(string(o.Str), 5); err != nil {
		ers = append(ers, err)
	}

	if err := support.ValidateMinLength(string(o.Str), 5); err != nil {
		ers = append(ers, err)
	}
	if err := support.ValidateEnum(string(o.Str), []string{"hello"}); err != nil {
		ers = append(ers, err)
	}

	if len(ers) != 0 {
		ctx = append(ctx, "str")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	ers = nil
	if err := support.ValidateMaxLength(string(o.StrNull.String), 5); err != nil {
		ers = append(ers, err)
	}

	if err := support.ValidateMinLength(string(o.StrNull.String), 5); err != nil {
		ers = append(ers, err)
	}
	if err := support.ValidateEnum(string(o.StrNull.String), []string{"hello"}); err != nil {
		ers = append(ers, err)
	}

	if len(ers) != 0 {
		ctx = append(ctx, "str_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}

	errs = support.AddErrs(errs, "", ers...)

	return errs
}
